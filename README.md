
# Console Application Development Using Numerical Methods

---

## üìå Table of Contents

<details>
<summary><strong>Project Overview</strong></summary>
  
- [Introduction](#introduction)
- [Project Overview](#project-overview)
- [Structure of Each Method](#structure-of-each-method)
- [Execution Flow](#execution-flow)
- [Input and Output Format](#input-and-output-format)
- [Technologies Used](#technologies-used)
- [Contributors](#contributors)
- [License](#license)

</details>

#### [Methods Implemented](#methods-implemented)

- **[Solution of Linear Equations](#solution-of-linear-equations)**

  <details>
  <summary><strong>Gauss Elimination Method</strong></summary>

  - [Theory](#gauss-elimination-theory)
  - [Code](#gauss-elimination-code)
  - [Input](#gauss-elimination-input)
  - [Output](#gauss-elimination-output)

  </details>

  <details>
  <summary><strong>Gauss Jordan Elimination Method</strong></summary>

  - [Theory](#gauss-jordan-theory)
  - [Code](#gauss-jordan-code)
  - [Input](#gauss-jordan-input)
  - [Output](#gauss-jordan-output)

  </details>

  <details>
  <summary><strong>LU Decomposition Method</strong></summary>

  - [Theory](#lu-decomposition-theory)
  - [Code](#lu-decomposition-code)
  - [Input](#lu-decomposition-input)
  - [Output](#lu-decomposition-output)

  </details>

  <details>
  <summary><strong>Matrix Inversion Method</strong></summary>

  - [Theory](#matrix-inversion-theory)
  - [Code](#matrix-inversion-code)
  - [Input](#matrix-inversion-input)
  - [Output](#matrix-inversion-output)

  </details>

- **[Solution of Non-linear Equations](#solution-of-non-linear-equations)**

  <details>
  <summary><strong>Bisection Method</strong></summary>

  - [Theory](#bisection-theory)
  - [Code](#bisection-code)
  - [Input](#bisection-input)
  - [Output](#bisection-output)

  </details>

  <details>
  <summary><strong>False Position Method</strong></summary>

  - [Theory](#false-position-theory)
  - [Code](#false-position-code)
  - [Input](#false-position-input)
  - [Output](#false-position-output)

  </details>

  <details>
  <summary><strong>Secant Method</strong></summary>

  - [Theory](#secant-theory)
  - [Code](#secant-code)
  - [Input](#secant-input)
  - [Output](#secant-output)

  </details>

  <details>
  <summary><strong>Newton-Raphson Method</strong></summary>

  - [Theory](#newton-raphson-theory)
  - [Code](#newton-raphson-code)
  - [Input](#newton-raphson-input)
  - [Output](#newton-raphson-output)

  </details>

- **[Solution of Differential Equations](#solution-of-differential-equations)**

  <details>
  <summary><strong>Runge-Kutta Method</strong></summary>

  - [Theory](#runge-kutta-theory)
  - [Code](#runge-kutta-code)
  - [Input](#runge-kutta-input)
  - [Output](#runge-kutta-output)

  </details>

- **[Interpolation and Approximation](#interpolation-and-approximation)**

  <details>
  <summary><strong>Newton Forward Interpolation</strong></summary>

  - [Theory](#newton-forward-theory)
  - [Code](#newton-forward-code)
  - [Input](#newton-forward-input)
  - [Output](#newton-forward-output)

  </details>

  <details>
  <summary><strong>Newton Backward Interpolation</strong></summary>

  - [Theory](#newton-backward-theory)
  - [Code](#newton-backward-code)
  - [Input](#newton-backward-input)
  - [Output](#newton-backward-output)

  </details>

  <details>
  <summary><strong>Newton Divided Difference Interpolation</strong></summary>

  - [Theory](#newton-divided-theory)
  - [Code](#newton-divided-code)
  - [Input](#newton-divided-input)
  - [Output](#newton-divided-output)

  </details>

- **[Numerical Integration](#numerical-integration)**

  <details>
  <summary><strong>Simpson‚Äôs 1/3rd Rule</strong></summary>

  - [Theory](#simpson-one-third-theory)
  - [Code](#simpson-one-third-code)
  - [Input](#simpson-one-third-input)
  - [Output](#simpson-one-third-output)

  </details>

  <details>
  <summary><strong>Simpson‚Äôs 3/8th Rule</strong></summary>

  - [Theory](#simpson-three-eighth-theory)
  - [Code](#simpson-three-eighth-code)
  - [Input](#simpson-three-eighth-input)
  - [Output](#simpson-three-eighth-output)

  </details>

- **[Numerical Differentiation](#numerical-differentiation)**

  <details>
  <summary><strong>Forward Interpolation Differentiation</strong></summary>

  - [Theory](#forward-diff-theory)
  - [Code](#forward-diff-code)
  - [Input](#forward-diff-input)
  - [Output](#forward-diff-output)

  </details>

  <details>
  <summary><strong>Backward Interpolation Differentiation</strong></summary>

  - [Theory](#backward-diff-theory)
  - [Code](#backward-diff-code)
  - [Input](#backward-diff-input)
  - [Output](#backward-diff-output)

  </details>

- **[Curve Fitting Regression](#curve-fitting-regression)**

  <details>
  <summary><strong>Least Squares Regression (Linear)</strong></summary>

  - [Theory](#ls-linear-theory)
  - [Code](#ls-linear-code)
  - [Input](#ls-linear-input)
  - [Output](#ls-linear-output)

  </details>

  <details>
  <summary><strong>Least Squares Regression (Transcendental)</strong></summary>

  - [Theory](#ls-trans-theory)
  - [Code](#ls-trans-code)
  - [Input](#ls-trans-input)
  - [Output](#ls-trans-output)

  </details>

  <details>
  <summary><strong>Least Squares Regression (Polynomial)</strong></summary>

  - [Theory](#ls-poly-theory)
  - [Code](#ls-poly-code)
  - [Input](#ls-poly-input)
  - [Output](#ls-poly-output)

  </details>

---

## üìñ Introduction
This project is a **console-based numerical methods application** developed as part of an academic group project under the **Department of Computer Science and Engineering (CSE)**.  
The application demonstrates the practical implementation of fundamental numerical techniques used to solve linear and non-linear equations, differential equations, interpolation, numerical integration, numerical differentiation, and curve fitting problems.

Each numerical method is presented in a structured manner including **theory, source code, sample input, and corresponding output**, ensuring both conceptual clarity and implementation understanding.

---

## üîç Project Overview
- **Project Type:** Academic Group Project  
- **Application Type:** Console-based Application  
- **Domain:** Numerical Methods  
- **Group Members:** 3  

The application allows users to select a numerical method from a menu, provide necessary inputs, and obtain numerical results.

---

## üßÆ Methods Implemented

### Solution of Linear Equations

### Gauss Elimination Method

#### Gauss Elimination Theory
[Add your theory content here]

#### Gauss Elimination Code
```cpp
# Add your code here
```

#### Gauss Elimination Input
```
[Add your input format here]
```

#### Gauss Elimination Output
```
[Add your output format here]
```

---  
### Gauss Jordan Elimination Method

#### Gauss Jordan Theory
[Add your theory content here]

#### Gauss Jordan Code
```cpp
# Add your code here
```

#### Gauss Jordan Input
```
[Add your input format here]
```

#### Gauss Jordan Output
```
[Add your output format here]
```

---

### LU Decomposition Method

#### LU Decomposition Theory
[Add your theory content here]

#### LU Decomposition Code
```cpp
# Add your code here
```

#### LU Decomposition Input
```
[Add your input format here]
```

#### LU Decomposition Output
```
[Add your output format here]
```

---  
### Matrix Inversion

#### Matrix Inversion Theory
[Add your theory content here]

#### Matrix Inversion Code
```cpp
# Add your code here
```

#### Matrix Inversion Input
```
[Add your input format here]
```

#### Matrix Inversion Output
```
[Add your output format here]
```  

---

### Solution of Non-linear Equations

### Bisection Method

#### Bisection Theory
[Add your theory content here]

#### Bisection Code
```cpp
# Add your code here
```

#### Bisection Input
```
[Add your input format here]
```

#### Bisection Output
```
[Add your output format here]
```

---
### False Position Method

#### False Position Theory
[Add your theory content here]

#### False Position Code
```cpp
# Add your code here
```

#### False Position Input
```
[Add your input format here]
```

#### False Position Output
```
[Add your output format here]
```

---
### Secant Method

#### Secant Theory
[Add your theory content here]

#### Secant Code
```cpp
# Add your code here
```

#### Secant Input
```
[Add your input format here]
```

#### Secant Output
```
[Add your output format here]
```

---
### Newton-Raphson Method

#### Newton-Raphson Theory
[Add your theory content here]

#### Newton-Raphson Code
```cpp
# Add your code here
```

#### Newton-Raphson Input
```
[Add your input format here]
```

#### Newton-Raphson Output
```
[Add your output format here]
```

---

### Solution of Differential Equations

### Runge-Kutta Method

#### Runge-Kutta Theory
[Add your theory content here]

#### Runge-Kutta Code
```cpp
# Add your code here
```

#### Runge-Kutta Input
```
[Add your input format here]
```

#### Runge-Kutta Output
```
[Add your output format here]
```  

---

### Interpolation and Approximation  

### Newton Forward Interpolation

#### Newton Forward Interpolation Theory
Newton's Forward Interpolation is used to estimate the value of an unknown variable `x` which is less than the middle value of the given data. This method is applicable when the difference between any two consecutive values of `x` is constant.

Let the given data points be  $x_0, x_1, \ldots , x_n$  with corresponding values  $y_0, y_1, \ldots , y_n$.

The data must satisfy the condition:

$$
x_i - x_{i-1} = h \quad \text{(constant)}, \quad 1 \le i \le n
$$

and the interpolation point should satisfy: 

$$
x < \frac{x_0 + x_n}{2}
$$



The forward difference is defined as:

$$
\Delta y_i = y_{i+1} - y_i
$$

Higher order forward differences are:

$$
\Delta^2 y_i = \Delta(\Delta y_i)
$$

$$
\Delta^3 y_i = \Delta(\Delta^2 y_i)
$$

and so on.



Let

$$
u = \frac{x - x_0}{h}
$$

Then the Newton's Forward Interpolation formula is given by

$$
y(x) = y_0+ u \Delta y_0+ \frac{u(u-1)}{2!} \Delta^2 y_0+ \frac{u(u-1)(u-2)}{3!} \Delta^3 y_0+ \cdots
$$

**Input Characteristics:**

The input starts with an integer $n$ - the number of variable $x$ and $y$.

The second line contains $n$ integers $x_i$ for $1\le i \le n$.

The third line contains $n$ integers $y_i$ for $1\le i \le n$.

The final line contains the value of $x$ for which the interpolated value is to be determined.

**Output Characteristics:**

Firstly, the output shows the Forward Difference Table.

Secondly, the interpolated value of $y$ is displayed.

#### Newton Forward Interpolation Code
```cpp
#include <bits/stdc++.h>
using namespace std;

long long fact(int n){
    long long f = 1;
    for(int i = 2; i <= n; i++){
        f *= i;
    }
    return f;
}

int main(){
    ifstream fin("input.txt");
    ofstream fout("output.txt");

    if(!fin){
        cout<<"Error: input.txt not found!"<<endl;
        return 0;
    }
    if(!fout){
        cout<<"Error: Can't open output.txt!"<<endl;
        return 0;
    }

    int n;
    fin>>n;

    double x[n], y[n][10];

    for(int i = 0; i < n; i++){
        fin>>x[i];
    }

    for(int i = 0; i < n; i++){
        fin>>y[i][0];
    }

    for(int j = 1; j < n; j++){
        for(int i = 0; i < n - j; i++){
            y[i][j] = y[i + 1][j - 1] - y[i][j - 1];
        }
    }

    fout<<"\nForward Difference Table:\n";
    for(int i = 0; i < n; i++){
        fout<<x[i]<<"\t";
        for(int j = 0; j < n - i; j++){
            fout<<y[i][j]<<"\t";
        }
        fout<<endl;
    }

    double value;
    fin>>value;

    double h = x[1] - x[0];
    double u = (value - x[0]) / h;

    double sum = y[0][0];
    double u_term = 1;

    for(int i = 1; i < n; i++){
        u_term *= (u - (i - 1));
        sum += (u_term * y[0][i]) / fact(i);
    }

    fout<<"\nInterpolated value at x = "<<value<<" is "<<sum<<endl;

    fin.close();
    fout.close();
    return 0;
}
```

#### Newton Forward Interpolation Input

```
4
3 5 7 9
180 150 120 90
4
```


#### Newton Forward Interpolation Output
```

Forward Difference Table:
3	180	-30	0	0	
5	150	-30	0	
7	120	-30	
9	90	

Interpolated value at x = 4 is 165
```



---
### Newton Backward Interpolation

#### Newton Backward Interpolation Theory
[Add your theory content here]

#### Newton Backward Interpolation Code
```cpp
# Add your code here
```

#### Newton Backward Interpolation Input
```
[Add your input format here]
```

#### Newton Backward Interpolation Output
```
[Add your output format here]
```

---
### Newton Divided Difference Interpolation

#### Newton Divided Difference Interpolation Theory
[Add your theory content here]

#### Newton Divided Difference Interpolation Code
```cpp
# Add your code here
```

#### Newton Divided Difference Interpolation Input
```
[Add your input format here]
```

#### Newton Divided Difference Interpolation Output
```
[Add your output format here]
```

---

### Numerical Integration
1. Simpson‚Äôs 1/3rd Rule  
2. Simpson‚Äôs 3/8th Rule  

---

### Numerical Differentiation
1. Differentiation using Forward Interpolation  
2. Differentiation using Backward Interpolation  

---

### Curve Fitting Regression
1. Least Squares Regression (Linear)  
2. Least Squares Regression (Transcendental)  
3. Least Squares Regression (Polynomial)  

---

## üß© Structure of Each Method
Each numerical method in the application consists of the following four components:

1. **Theory** ‚Äì Mathematical background and explanation  
2. **Code** ‚Äì Algorithmic implementation  
3. **Input** ‚Äì User-provided data  
4. **Output** ‚Äì Computed numerical result  

---

## üîÑ Execution Flow
1. 
2.   
3.   
4.   

---

## ‚å® Input and Output Format
- **Input:** Numerical values, matrices, initial guesses, step size, or data points  
- **Output:** Approximate solution and final result  

All interactions are performed via the console.

---

## üõ† Technologies Used
- **Programming Language:** C / C++  
- **Compiler:** GCC / g++  
- **Development Environment:** Code::Blocks / VS Code  
- **Platform:** Windows / Linux  

---

## üë• Contributors
This project was developed by a group of **three students**:

- Member 1 ‚Äì Roll No:  2207045
- Member 2 ‚Äì Roll No:  2207046
- Member 3 ‚Äì Roll No:  2207048

---

## üìú License
This project is intended **strictly for academic and educational purposes**.  
Unauthorized commercial use is prohibited.

¬© 2025 Department of Computer Science and Engineering
